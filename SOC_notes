STREAM OF CONSCIOUSNESS NOTES:

Jan 23:
    Goals for the week:
        Take look at btrFS stuff
        Look back at thread
        Looking through the fork
        Plan to meet on Thursday
        Postpone till after thursday
            Attempting to get linux on the machine running ZFS and btrFS
Jan 24:
    Reading BTRFS_The_Linux_B-tree_Filesystem.pdf -> good amount of similarities to ZFS but fundamentally different hierarchical structure
        No concrete mention of -`reflink`s but does a great job outlining btrFS basics and how writing and freeing blocks works
    Re exploring this feature request on ZFS https://github.com/openzfs/zfs/issues/405 and https://github.com/pjd/openzfs/commit/83921c797a65fbc46a72e2a90c40822a988dee28
Jan 25:
    Working on the "how" presentation
    Updated bibliography with all new sources
Jan 26:
    Read through feature request thread again https://github.com/openzfs/zfs/issues/405 "COW cp (--reflink) support #405"
    Explored https://github.com/openzfs/zfs/discussions/4237
    Also https://github.com/openzfs/zfs/issues/1063 "Please implement "cp --reflink=always" with ZoL #1063"
    Also https://github.com/openzfs/zfs/issues/2554 "btrfs bedup equivalent #2554"
        - "There's 2 ways a block can be referenced multiple times: dedup and snapshots. You can't "instantly" clone a file because doing it that way doesn't meet either criteria. In contrast BTRFS seems to use some crazy layers of indirection and trees to let it do that."
    Presentation https://www.usenix.org/legacy/event/lsf07/tech/rodeh.pdf
    WAFL implementation https://community.netapp.com/t5/Microsoft-Virtualization-Discussions/What-is-SIS-Clone/td-p/6462
        "SIS clone is a capability withing Data ONTAP to run the dedupe engine in reverse to clone a file.  Instead of copying all the block, and then removing the duplicate blockd at a later date.  Instead we create a sparse file  (non-allocated) and then SIS clone manipulates the WAFL pointers in the destination file to point to the blocks for the source file. The end result is an exact copy of the source file that is pre-deduped.  The benefit of SIS-Clone is we can manipulate WAFL pointers even faster than we can write block, so the copy operation is an order of magnitude quicker. "
    Already implemented in XFS https://strugglers.net/~andy/blog/2017/01/10/xfs-reflinks-and-deduplication/
    "FAST-Tracking REFLINK and Offline Deduplication, first for LINUX only #13349" https://github.com/openzfs/zfs/issues/13349
    Oracle ZFS has reflinks already? https://blogs.oracle.com/solaris/post/reflink3c-what-is-it-why-do-i-care-and-how-can-i-use-it
    Block Cloning Table branch https://github.com/openzfs/zfs/pull/13392
        Explanation video https://www.youtube.com/watch?v=hYBgoaQC-vo

    Notes with pete:
        Why inst the naive approach sufficient
        Maybe dive deep into why the BRT has been implemented when it doesn't need to be

    TODO:
        (done) How referencing is done 
        (done) How snapshots do the referencing
        (done) Grep the source code
            Find the field in the struct that is the reference count and find every usage of it
        (done) One last deep dive into why the naive solution doesnt work
        Get the BRT branch downloaded and compiled -> probably on Linux


Jan 27:
    How referencing is done
        Reread block referencing section of The_Design_and_Implementation_of_the_FreeBSD_Operating_System
            Space allocation handled by the Storage Pool Allocator (SPA) module (LOOK INTO SOURCE CODE OF)
                SPA looks up available space in the MOS space map.
                1. Chooses the disk with the most free space
                2. From the fixed-sie space maps describing the space on the disk select the one that is the least fragmented
                3. Allocate a chunk of space with the needed size that is closest to the previous allocation
            Freeing blocks -> ZFS tracks its used and available blocks using space maps, birth time, and deadliest
            Deduplication also increments a blocks associated reference count.

    How snapshots do the referencing
        Reread block referencing section of The_Design_and_Implementation_of_the_FreeBSD_Operating_System
            Checkpoint to make sure everything is up to date
            Allocate a new dnode that will represent the snapshot
            Copy over the block pointer from the current filesystem being snapshotted to the newly allocated snapshot dnode
            Link the new dnode to the head of the filesystem's snapshot list (youngest snapshot)
            Add snapshot name etc...

    Existing design considerations:
        "File-cloning can be thought of as hard-links with copy-on-write properties Use-cases include cloning VM images and other large files  or being able to recover files from snapshots, fast and without additional space Implementation: Dedup comes to mind as the end-functionality is somewhat similar. That said we would like this to be a generic feature of ZFS and not a feature flag. We’d also like to avoid the performance issues that come with dedup. Current idea revolves around a new block-reference table, a mapping of vdev_id+offset to a refcount. The attempt would be to avoid overhead in reads/writes and just put the overhead in when freeing blocks with more than one reference (to make such operations performant we’d probably need to maintain most if not all of our structures/metadata in memory). There are a few implementation questions that we’d need to iron-out. For example, do we expect this to work across datasets? If that’s the case how would it affect send/receive assuming we want to maintain the cloning-property? What about memory? Can’t that table grow too big? We’d probably need to think hard of how the table is managed and how to avoid unpredictable performance."

    Watched https://www.youtube.com/watch?v=hij7PGGjevc talking about 98% done
        For BRT we dont have a specific bit that we need to check table we have to check for every free.
            What if we used one of the free bits in the dnode struct
        Keys are not random so lookup is better and faster
            vdev is in a range, and keep how many references is in the range
            Small 1mb per terabits
            Helps us know if the block might be in the brt
                We can immediately tell if it is not

Jan 29th
    Watched design implementation talk https://www.youtube.com/watch?v=Y9HQ4RbqIEw
        Could reuse dedup, just read the checksum from block pointers and make a new file pointing to the same checksum
            "We dont want this to be another dedup"
        "The problem is of course, if we have a data block on the disk and we have a block pointer pointing at this block, we cannot have a reference counter in this block pointer because, of course, we can not modify block pointer."

        Powels idea was to create something similar to dedup
            Things with a reference count of one dominate the dedup table
            The block reference table will only have entries when their reference count is greater than one
        In the dedup table they are data hashes so they can not be sorted really
            Not good for caching or easy lookup
        "We have a block of data, and we have a block pointer pointing at the data, and we can not modify that. But once you call this clone file system call. We will read the existing block pointers, create new block pointers, just copying the data from the original block pointers. Storing them in a new file and creating entries in the block reference tables. The entry is only created when the block is actually cloned. So if you don't use the functionally there is no 'price to pay'." 
        No performance impact on read or write, only when a block pointer is freed do we have to consult to block reference table.
        "When we free the block we can not really tell if the block has more than one reference" ---- WHYYYYYY
        "Deduplication has the dedup bit set"
        Deduplication Table entry is 392 bytes
        Block Reference Table entry is 80 bytes or smaller
            Plus it is sortable
            "The block reference table is basically a mapping from the vdev + offset to the refcount. You do a lot better by putting it in a dataset that is sorted
        One idea for better free performance would be to actually have a bit in the block pointer structure that then triggers us to look into the block reference table
        To have send/receive work you would need massive post-processing after the fact
        In-memory cost is 10x smaller than DDT
    How does snapshots increment block references... It should be THE SAME PROCESS

Jan 30th
    https://docs.google.com/document/d/1w2jv2XVYFmBVvG1EGf-9A5HBVsjAYoLIFZAnWHhV-BM/edit#heading=h.7pnof6czteeh (DEVELOPER NOTES)
    Started looking at source code. Trying to find when block references are changed.
    https://github.com/openzfs/zfs/pull/13392
        - for BRT we only store 64bit offset and 64bit reference counter
    What if we added in a reference count 64bits into the block reference structure rather than the block reference table
    There are 2, 64 bit spare spaces in each block reference structure
    ./include/sys/spa.h has the definition of the block pointer structure. Has two 64-bit padding chunks
        If we use one of these, then the block reference table is irrelevant. We not longer have the negative side effects of freeing a block and therefore the cloning can be turned on by default and therefore be much better than a new deduplication table DDT but for the block pointer table. Now, just when freeing blocks it is as easy as decrementing the block clone reference count.

Feb 1st
    Might need dnodes to point at THE SAME BLOCK POINTER not just a duplicate -> he same block pointer